#include <bits/stdc++.h>
using namespace std;
 
template <class DataType> struct node
{
    DataType data; // data to be stored
    node* next; // pointer to the next element
};
 
template <class DataType> class LinkedList
{
    node<DataType>* head; // pointer to the first element
public:
// linked list operations
    LinkedList() : head(NULL) {};
    //LinkedList (const LinkedList<DataType> & aplist); // initializes the current list with the given list.
    //~LinkedList();
    void addFirst(DataType value); // add element at the beginning of the list
    void add(DataType value); // add element at the end of the list
    bool insert (const DataType & element, int pos); // inserts an element atan exact position
    int length(); // returns the number of elements in the list
    bool first (DataType & listEl);// returns first element of list
 
    node<DataType>* retrieve (DataType & element); // returns node of found element or null otherwise
    friend LinkedList merge(LinkedList A,LinkedList B);
    bool remove (DataType element); // returns true if element is found
    void Display();
    bool isEmpty() const; // returns true if linked list is empty
    void clear(); // removes all the elements in the list
};
 
//
//LinkedList::LinkedList(const LinkedList<DataType> & aplist)
 
template <class DataType>
void LinkedList<DataType>::addFirst(DataType ele)
{
 
    node<DataType> *temp = new node<DataType>;
    temp->data = ele;
    temp->next = head;
    head = temp;
}
 
template <class DataType>
void LinkedList<DataType>::add(DataType ele)
{
    node<DataType> *temp;
    for(temp = head; temp->next != NULL ; temp = temp->next);
 
    node<DataType> *tail = new node<DataType>;
    tail->data = ele ;
    tail->next = NULL;
    temp->next = tail;
}
 
template <class DataType>
int LinkedList<DataType>::length()
{
    int count = 0;
    node<DataType> *temp = new node<DataType>;
    temp = head;
    while(temp->next != NULL)
    {
        count++;
        temp = temp->next;
    }
    return count;
}
 
template <class DataType>
bool LinkedList<DataType>::insert(const DataType &ele, int pos)
{
 
    if(pos >= length() || pos <= 0)
        return false;
    node<DataType> *temp = new node<DataType>;
    temp->data = ele;
 
    node<DataType> *prev = NULL;
    node<DataType> *cuur = head;
 
 
    for(int i=0; i < pos; ++i)
    {
        prev = cuur;
        cuur = cuur->next;
    }
 
 
    temp->next = cuur;
    prev->next = temp;
 
    return true;
}
 
template <class DataType>
bool LinkedList<DataType>::remove(DataType ele)
{
    node<DataType>* curr = head;
    node<DataType>* prev = NULL;
 
    while(curr->next != NULL )
    {
        if(curr ->data == ele)
        {
            prev->next = curr->next;
            delete curr;
            return true;
        }
        prev = curr;
        curr = curr->next;
    }
    return false;
}
 
template <class DataType>
 
void LinkedList<DataType>::Display()
{
 
    node<DataType> *temp = head;
    while(temp->next != NULL)
    {
        cout << temp->data <<" ";
        temp = temp->next;
    }
 
}
 
template <class DataType>
LinkedList<DataType> merge ( LinkedList<DataType> A, LinkedList<DataType> B )
{
    node<DataType> *temp1 = A.head;
    node<DataType> *temp2 = B.head;
    LinkedList<DataType> res;
    while(temp1->next != NULL && temp2->next !=NULL)
    {
        if(temp1->data < temp2->data)
            res.addFirst(temp1->data);
        else
            res.addFirst(temp2->data);
 
        temp1 = temp1->next;
        temp2 = temp2->next;
    }
    while(temp1->next != NULL)
        res.addFirst(temp1->data);
    while(temp2->next != NULL)
        res.addFirst(temp2->data);
 
    return res;
}
 
template <class DataType>
class Stack
{
 
private:
    DataType *arr;
    int ssize;
    int top;
public:
    Stack(int s) :ssize(s > 0 ? s : 10), top(-1),arr(new DataType[s]) {}
 
    DataType pop()
    {
        if(top != -1)
        {
 
            return arr[top--];
        }
        else
            cout << "E" <<endl;
        return NULL;
 
    }
 
    DataType Top()
    {
        if(top != -1)
            return arr[top];
        else
            cout << "Is" << endl;
 
    }
 
    void Push(const DataType &t)
    {
        if(top != ssize)
        {
            arr[++top] = t;
        }
        else
            cout << "is full" << endl;
    }
 
    void Display()
    {
        for(int i=top ; i >= 0; i--)
        {
            cout << arr[i] << " ";
        }
        cout << endl;
 
    }
 
 
};
 
 
template <class DataType>
class Queue
{
 
private:
    DataType *elem;
    int ssize;
    int tail;
public:
    Queue(int s)
    {
        ssize(s);
        elem = new DataType[ssize];
        tail = -1;
    }
    void enqueue(const DataType &t)
    {
        if(tail != ssize)
            elem[++tail] = t;
        else
            cout << "Full" <<endl;
    }
 
    DataType dequeue()
    {
        DataType top = elem[0];
        if(tail != -1)
        {
            for(int i=0; i < tail; ++i)
            {
                elem[i] = elem[i+1];
            }
            tail--;
            return top;
        }
        else
        {
            cout << "E" <<endl;
        }
    }
 
 
};
 
int BinnarySaerch(int *arr,int item,int low,int high)
{
    int in = -1;
    int mid;
    while(low<=high)
    {
 
        mid = (low + high)/2;
        if(arr[mid] == item)
        {
            in = mid;
            return in;
        }
        else if(item > arr[mid])
        {
            low = mid+1;
        }
        else
        {
            high = mid-1;
        }
    }
 
}
 
void puppl(int *arr,int x)
{
 
    for(int i=x-1; i >= 0; --i)
    {
        for(int j=0; j < i; ++j )
        {
            if(arr[j] > arr[j+1])
                swap(arr[j],arr[j+1]);
        }
    }
}
 
void insertion(int *arr,int s)
{
 
    for(int i=1; i < s; ++i)
    {
        int index = i;
        while( index>0 &&(arr[index-1]>arr[index]))
        {
            swap(arr[index-1],arr[index]);
            index--;
        }
    }
 
}
 
void Merge(int* ipA, int iEnd1, int iEnd2)
{
    int i = 0;
    int j = iEnd1;
    int k = 0;
    int* ipTemp = new int[iEnd2];
    // Take each next smallest element
    while (i < iEnd1 && j < iEnd2)
    {
        if (ipA[i] < ipA[j])
        {
            ipTemp[k] = ipA[i];
            ++i;
        }
        else
        {
            ipTemp[k] = ipA[j];
            ++j;
        }
        ++k;
    }
 
    // Copy any remaining elements of the 1st array
    while (i < iEnd1)
    {
        ipTemp[k] = ipA[i];
        ++i;
        ++k;
    }
 
    // Copy any remaining elements of the 2nd array
    while (j < iEnd2)
    {
        ipTemp[k] = ipA[j];
        ++j;
        ++k;
    }
 
    // Copy the merged array back to the original
    for (int iIndex = 0; iIndex < iEnd2; ++iIndex)
    {
        ipA[iIndex] = ipTemp[iIndex];
    }
    delete [] ipTemp;
}
 
void sort(int *iaArray,int iSize)
{
 
    for (int i = 1; i < iSize; i *= 2)
    {
        for (int j = 0; j < iSize - i; j += 2*i)
        {
            int iEnd2 = (2*i < iSize - j) ? 2*i : iSize - j;
            Merge(&(iaArray[j]), i, iEnd2);
        }
    }
 
 
}
 
void Partition(int* ipA, int iSize)
{
 
    // Partitions of size 0 or 1 are already sorted
    if (iSize <= 1)
    {
        return;
    }
 
    // Select a pivot from the array randomly
    int iPivot = ipA[rand() % iSize];
 
    // Indices of the entries to be swapped
    int iLower = 0;
    int iUpper = iSize - 1;
 
    // Partition array into sections above and below the pivot
    while (iLower < iUpper)
    {
 
        while (ipA[iLower] < iPivot)
        {
            ++iLower;
        }
 
        while (ipA[iUpper] > iPivot)
        {
            --iUpper;
        }
        // Swap the entries at the lower and upper indices
        swap(ipA[iLower],ipA[iUpper]);
    }
 
    // Recursively call partition on each partititon.
    Partition(ipA, iLower);
    Partition(&(ipA[iLower + 1]), iSize - iLower - 1);
}
 
void Quicksort(int* ipA, int iSize)
{
    // Seed the random number generator
    srand((unsigned int)time(0));
    Partition(ipA, iSize);
}
 
void selection(int *arr,int size)
{
 
    for(int i=0; i < size-1; ++i)
    {
        int in = i;
        for(int j=i+1; j<size; ++j)
        {
            if(arr[in] > arr[j])
                in = j;
        }
        swap(arr[in],arr[i]);
    }
 
}
 
int main()
{
 
    int arr[6] = {3,4,1,5,6,2};
    selection(arr,6);
    for(int i=0; i < 6; ++i)
    {
        cout << arr[i] << " ";
    }
 
 
}
 
